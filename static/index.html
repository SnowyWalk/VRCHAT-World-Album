<!doctype html>
<html lang="ko" data-theme="dark">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>VRCHAT Worlds Album</title>
    <link rel="stylesheet" href="/static/css/style.css" />
</head>

<body>
    <header class="container header">
        <h1>VRCHAT Worlds Album</h1>
        <div class="toolbar">
            <label class="sel">
                <span>ì •ë ¬</span>
                <select id="sortSel" aria-label="ì •ë ¬">
                    <option value="added">ì¶”ê°€ëœ ì‹œê°„ ìˆœ(ìµœì‹ )</option>
                    <option value="added_old">ì¶”ê°€ëœ ì‹œê°„ ìˆœ(ì˜¤ë˜ë¨)</option>
                    <option value="visits">ë°©ë¬¸ì ìˆœ</option>
                    <option value="favorites">ì¦ê²¨ì°¾ê¸° ìˆœ</option>
                    <option value="favratio">ì¦ê²¨ì°¾ê¸° ë¹„ìœ¨ ìˆœ</option>
                    <option value="updated">ìµœê·¼ ì—…ë°ì´íŠ¸ ìˆœ</option>
                    <option value="heat">heat ìˆœ</option>
                    <option value="popularity">popularity ìˆœ</option>
                </select>
            </label>
            <button id="themeBtn" class="theme-btn" aria-label="í…Œë§ˆ ì „í™˜">ğŸŒ™</button>
        </div>
    </header>

    <div id="status" class="container muted"></div>
    <main id="grid" class="grid container" aria-live="polite"></main>

    <footer class="container muted">Â© 2025 VRCHAT Worlds Album</footer>

    <!-- ë¼ì´íŠ¸ë°•ìŠ¤ -->
    <div class="modal" id="lightbox" aria-modal="true" role="dialog">
        <button class="btn close" id="bClose" aria-label="ë‹«ê¸°">âœ•</button>
        <div id="viewer" class="viewer">
            <button class="hit prev" id="hitPrev" aria-label="ì´ì „ ì‚¬ì§„ ë³´ê¸°"><span class="ico">â†</span></button>
            <img id="big" alt="" />
            <button class="hit next" id="hitNext" aria-label="ë‹¤ìŒ ì‚¬ì§„ ë³´ê¸°"><span class="ico">â†’</span></button>
        </div>
        <div id="film" class="film" role="listbox" aria-label="ì¸ë„¤ì¼ ëª©ë¡"></div> <!-- â† ì¶”ê°€ -->
        <div id="cap" class="caption"></div>
    </div>

    <script>
        let _imgReqToken = 0
        const _imgCache = new Map()
        const _thumbCache = new Map()
        const $ = s => document.querySelector(s)
        const el = (t, p = {}, ...c) =>
        {
            const n = document.createElement(t)
            for (const [k, v] of Object.entries(p))
            {
                if (k === "class")
                {
                    n.className = v
                } else if (/^on[A-Z]/.test(k) && typeof v === "function")
                {
                    // onClick, onKeydown ë“± â†’ click, keydown ìœ¼ë¡œ ì •ê·œí™”
                    n.addEventListener(k.slice(2).toLowerCase(), v)
                } else if (v != null)
                {
                    n.setAttribute(k, v)
                }
            }
            for (const x of c) n.append(x?.nodeType ? x : document.createTextNode(x ?? ""))
            return n
        }

        const grid = $("#grid"), status = $("#status")
        const light = $("#lightbox"), big = $("#big"), cap = $("#cap"), bClose = $("#bClose"),
            hitPrev = $("#hitPrev"), hitNext = $("#hitNext"), film = $("#film")
        const sortSel = $("#sortSel"), themeBtn = $("#themeBtn")
        let STATE = { worlds: [], sort: localStorage.getItem("sort") || "added" };

        /* í…Œë§ˆ í† ê¸€ */
        (function initTheme()
        {
            const saved = localStorage.getItem("theme")
            if (saved)
            {
                document.documentElement.setAttribute("data-theme", saved)
                themeBtn.textContent = saved === "dark" ? "ğŸŒ™" : "â˜€ï¸"
            } else if (window.matchMedia && window.matchMedia("(prefers-color-scheme: light)").matches)
            {
                document.documentElement.setAttribute("data-theme", "light")
                themeBtn.textContent = "â˜€ï¸"
            }
            themeBtn.addEventListener("click", () =>
            {
                const cur = document.documentElement.getAttribute("data-theme") || "dark"
                const next = cur === "dark" ? "light" : "dark"
                document.documentElement.setAttribute("data-theme", next)
                localStorage.setItem("theme", next)
                themeBtn.textContent = next === "dark" ? "ğŸŒ™" : "â˜€ï¸"
            })
        })()

        /* ë¼ì´íŠ¸ë°•ìŠ¤ (ë²„ê·¸í”½ìŠ¤: ë‚´ë¶€ ì´ë¯¸ì§€ í´ë¦­ ì‹œ ë‹«í˜ ë°©ì§€, ì¸ë„¤ì¼â†’ì›ë³¸ ê²½ë¡œ ë¶„ë¦¬) */
        let currList = [], currIdx = 0, currWorldName = ""
        let currThumbs = [] // â† ì¸ë„¤ì¼ ê²½ë¡œ ë°°ì—´

        function openLight(list, i = 0, worldName = "", thumbs = null)
        {
            if (!Array.isArray(list) || list.length === 0) return
            document.documentElement.classList.add('lb-open')
            currList = list
            currIdx = Math.max(0, Math.min(i, list.length - 1))
            currWorldName = worldName || ""
            currThumbs = Array.isArray(thumbs) && thumbs.length === list.length ? thumbs : list

            setBigImage(
                currList[currIdx],
                `${currWorldName} ì‚¬ì§„ ${currIdx + 1}/${currList.length}`,
                currThumbs[currIdx]
            )
            cap.textContent = `${currWorldName} Â· ${currIdx + 1}/${currList.length}`
            renderFilm(currThumbs)

            light.setAttribute("open", "")
            lockScroll()                                      // âœ… í­ ìœ ì§€í•œ ì±„ ìŠ¤í¬ë¡¤ ê³ ì •
            requestAnimationFrame(updateLbReserve)
            preloadThumbNeighbors(currThumbs, currIdx)
            preloadNeighbors(currList, currIdx)
        }

        function closeLight()
        {
            light.removeAttribute("open")
            document.documentElement.classList.remove('lb-open')
            unlockScroll()                                     // âœ… ì›ë³µ + ì›ë˜ ìŠ¤í¬ë¡¤ ìœ„ì¹˜ ë³µêµ¬
            big.src = ""
            cap.textContent = ""
        }

        function move(d)
        {
            if (!currList.length) return
            currIdx = (currIdx + d + currList.length) % currList.length
            setBigImage(
                currList[currIdx],
                `${currWorldName} ì‚¬ì§„ ${currIdx + 1}/${currList.length}`,
                currThumbs[currIdx]               // â† í”„ë¦¬ë·° ì „ë‹¬
            )
            cap.textContent = `${currWorldName} Â· ${currIdx + 1}/${currList.length}`
            updateFilmActive()
            requestAnimationFrame(updateLbReserve)
            preloadThumbNeighbors(currThumbs, currIdx)
            preloadNeighbors(currList, currIdx)
        }

        function jumpTo(i)
        {
            if (!currList.length) return
            currIdx = Math.max(0, Math.min(i, currList.length - 1))
            setBigImage(
                currList[currIdx],
                `${currWorldName} ì‚¬ì§„ ${currIdx + 1}/${currList.length}`,
                currThumbs[currIdx]               // â† í”„ë¦¬ë·° ì „ë‹¬
            )
            cap.textContent = `${currWorldName} Â· ${currIdx + 1}/${currList.length}`
            updateFilmActive()
            requestAnimationFrame(updateLbReserve)
            preloadThumbNeighbors(currThumbs, currIdx)
            preloadNeighbors(currList, currIdx)
        }


        bClose.onclick = closeLight
        hitPrev.onclick = () => move(-1)
        hitNext.onclick = () => move(+1)
        light.addEventListener("click", e =>
        {
            if (e.target === light) closeLight()
        })
        big.addEventListener("click", e => e.stopPropagation()) // ë‚´ë¶€ í´ë¦­ì€ ìœ ì§€
        film.addEventListener("click", e => e.stopPropagation())

        /* ìœ í‹¸ */
        function pct(fav, vis)
        {
            const v = Number(vis) || 0
            const f = Number(fav) || 0
            if (v <= 0) return "0%"
            // ì´ìƒì¹˜ ë°©ì§€: 0~100%ë¡œ í´ë¨í”„(+ì†Œìˆ˜ 1ìë¦¬, 10% ì´ìƒì€ ì •ìˆ˜)
            let p = (f / v) * 100
            if (!isFinite(p)) p = 0
            p = Math.max(0, Math.min(100, p))
            return (p >= 10 ? Math.round(p) : p.toFixed(1)) + "%"
        }

        function favRatioNum(w)
        {
            const v = Number(w.visits) || 0, f = Number(w.favorites) || 0
            return v > 0 ? f / v : 0
        }

        function chips(tags)
        {
            if (!Array.isArray(tags)) return []
            return tags.filter(t => t.startsWith("author_tag_"))
                .map(t => t.replace(/^author_tag_/, ""))
                .map(txt => el("span", { class: "chip" }, txt))
        }

        function toTs(v)
        {
            return typeof v === "number" ? v : (Date.parse(v || "") || 0)
        }

        function renderFilm(thumbs)
        {
            film.innerHTML = ""
            thumbs.forEach((src, i) =>
            {
                const btn = el("button", {
                    class: "t" + (i === currIdx ? " active" : ""),
                    role: "option",
                    "aria-selected": i === currIdx ? "true" : "false",
                    onClick: () => jumpTo(i),
                    onKeydown: (e) =>
                    {
                        if (e.key === "Enter" || e.key === " ") { e.preventDefault(); jumpTo(i) }
                    }
                }, el("img", { src, alt: `${currWorldName} ì¸ë„¤ì¼ ${i + 1}` }))
                btn.addEventListener("mousedown", e => e.preventDefault())
                film.append(btn)
            })
            // í˜„ì¬ ì„ íƒ ì¸ë„¤ì¼ì´ ë³´ì´ë„ë¡ ìŠ¤í¬ë¡¤
            queueMicrotask(() =>
            {
                const active = film.querySelector(".t.active")
                active?.scrollIntoView({ block: "nearest", inline: "center", behavior: "smooth" })
            })
        }

        function updateFilmActive()
        {
            const nodes = film.querySelectorAll(".t")
            nodes.forEach((n, i) =>
            {
                const on = i === currIdx
                n.classList.toggle("active", on)
                n.setAttribute("aria-selected", on ? "true" : "false")
            })
            const active = film.querySelector(".t.active")
            active?.scrollIntoView({ block: "nearest", inline: "center", behavior: "smooth" })
        }

        let _swapTimer = null
        // í”„ë¦¬ë·° â†’ ì›ë³¸, ë¹ˆ í”„ë ˆì„ ì—†ì´ ë¶€ë“œëŸ½ê²Œ êµì²´(í† í°ê°€ë“œ + decode)
        async function setBigImage(fullSrc, altText, previewSrc)
        {
            const token = ++_imgReqToken
            big.alt = altText || ""
            big.setAttribute("fetchpriority", "high")

            const show = (url) =>
            {
                if (token !== _imgReqToken) return
                if (big.src !== url) big.src = url
            }

            // 1) ì›ë³¸ì´ ìºì‹œì— ì™„ì „ ë¡œë“œë˜ì–´ ìˆìœ¼ë©´ ì¦‰ì‹œ êµì²´
            const fCached = _imgCache.get(fullSrc)
            if (fCached?.complete && fCached.naturalWidth)
            {
                show(fullSrc)
                return
            }

            // 2) í”„ë¦¬ë·°ë¥¼ ë¨¼ì € ë³´ì—¬(ë°˜ì‘ì„±â†‘). ê¸°ì¡´ srcëŠ” ë¹„ìš°ì§€ ì•ŠìŒ â†’ ë¹ˆ í”„ë ˆì„ ì—†ìŒ
            if (previewSrc && previewSrc !== fullSrc && big.src !== previewSrc)
            {
                let tImg = _thumbCache?.get(previewSrc)
                if (!tImg)
                {
                    tImg = new Image()
                    tImg.decoding = "async"
                    tImg.src = previewSrc
                    _thumbCache?.set?.(previewSrc, tImg)
                }
                show(previewSrc)
            }

            // 3) ì›ë³¸ ë¹„ë™ê¸° ë¡œë“œ + decodeê¹Œì§€ ëë‚œ ë’¤ êµì²´(ê¹œë¹¡ì„ ì œê±°)
            let loader = fCached instanceof Image ? fCached : new Image()
            loader.decoding = "async"
            if (!fCached) loader.src = fullSrc

            try
            {
                if (!loader.complete) await loader.decode()
            } catch (_) { /* ì‹¤íŒ¨ ì‹œ í”„ë¦¬ë·° ìœ ì§€ */ }

            _imgCache.set(fullSrc, loader)
            show(fullSrc)
        }




        function updateLbReserve()
        {
            // ì—´ë¦° ìƒíƒœì—ì„œ ì‹¤ì œ ë†’ì´ë¥¼ ì¸¡ì •
            const filmH = light.hasAttribute('open') ? (film?.offsetHeight || 0) : 0
            const capH = cap?.offsetHeight || 0
            const btnH = 0 //Math.max(bPrev?.offsetHeight || 0, bNext?.offsetHeight || 0)
            const margin = 28 // ì—¬ìœ  ê°„ê²©(ê²¹ì¹¨ ë°©ì§€ ë²„í¼)
            const reserve = Math.ceil(filmH + Math.max(capH, btnH) + margin)
            document.documentElement.style.setProperty('--lb-reserve', reserve + 'px')
        }

        /* ì¹´ë“œ */
        function card(w)
        {
            const url = w.url
            const author = w.authorName || ""
            const heroImg = el("img", {
                src: w.imageUrl || w.thumbnailImageUrl || "",
                alt: `${w.name} ì¸ë„¤ì¼`,
                loading: "lazy",
                decoding: "async"
            })
            const hero = el("a", { class: "hero", href: url, target: "_blank", rel: "noopener noreferrer" }, heroImg)
            const title = el("a", {
                href: url,
                target: "_blank",
                rel: "noopener noreferrer",
                class: "title"
            }, w.name || w.id)

            let authorAttr = null
            if (w.authorName)
            {
                const linkNode = w.authorId
                    ? el("a", {
                        href: `https://vrchat.com/home/user/${w.authorId}`,
                        target: "_blank",
                        rel: "noopener noreferrer",
                        class: "author-link"
                    }, w.authorName)
                    : el("span", { class: "author-link" }, w.authorName)

                authorAttr = el("div",
                    // { class: "stat-row author-attr" },
                    // el("span", { class: "label" }, "ì œì‘ì "),
                    { class: "author-attr" },
                    linkNode
                )
            }

            const titleLine = el("div", { class: "title-line" }, title, authorAttr)
            const stats1 = el("div", { class: "stat-row" }, `ë°©ë¬¸ ${w.visits.toLocaleString("en-US") ?? 0}`)

            // ì¦ê²¨ì°¾ê¸° + ë¯¸ë‹ˆ íˆíŠ¸ë§µ(ì˜¤ë¥¸ìª½ ê²Œì´ì§€)
            const ratio = favRatioNum(w) // 0~1
            const stats2 = el("div", { class: "stat-row favrow" },
                el("span", {}, `ì¦ê²¨ì°¾ê¸° ${Number(w.favorites || 0).toLocaleString("en-US")}`),
                el("span", { class: "mini-pct" }, pct(w.favorites, w.visits)),
                (() =>
                {
                    const m = el("span", { class: "mini" },
                        el("span", { class: "mini-bar" })
                    )
                    m.querySelector(".mini-bar")
                        .style.setProperty("--ratio", String(Math.max(0, Math.min(1, ratio))))
                    return m
                })()
            )



            const capRow = el("div", { class: "meta" }, `ìµœëŒ€ ì¸ì› ${w.capacity ?? "-"}`)
            const hpRow = el("div", { class: "icons" },
                el("span", { class: "icon" }, `${repeatString("ğŸ”¥ ", Number(w.heat ?? 1))} `, String(w.heat ?? "-")),
                el("span", { class: "icon" }, `${repeatString("â­", Number(w.popularity ?? 1))} `, String(w.popularity ?? "-"))
            )
            const tagWrap = el("div", { class: "tags" }, ...chips(w.tags))
            const desc = el("p", { class: "desc" }, (w.description || "").trim())

            // ìŠ¤ëƒ…ìƒ·
            const maxThumbs = 6
            const strip = el("div", { class: "strip" })


            const photos = Array.isArray(w.photos) ? w.photos : []
            // ê° í•­ëª©ì€ ë¬¸ìì—´ ë˜ëŠ” {full,thumb,view}
            const norm = photos.map(p => typeof p === "string" ? { full: p, thumb: p, view: p } : {
                full: p.full, thumb: p.thumb || p.full, view: p.view || p.full
            })
            const fullList = norm.map(p => p.view)
            const thumbList = norm.map(p => p.thumb)


            photos.slice(0, maxThumbs).forEach((p, i) =>
            {
                const thumbSrc = (typeof p === "string") ? p : (p.thumb || p.full)
                const isLast = i === maxThumbs - 1 && photos.length > maxThumbs
                const open = () => openLight(fullList, i, w.name || w.id, thumbList)


                if (isLast)
                {
                    const remain = photos.length - maxThumbs + 1
                    strip.append(
                        el("div", { class: "more", "data-more": "+ " + remain, role: "button", tabindex: "0", onClick: open },
                            el("img", {
                                class: "thumb",
                                src: thumbSrc,
                                alt: `${w.name} ì‚¬ì§„`,
                                loading: "lazy",
                                decoding: "async"
                            })
                        )
                    )
                } else
                {
                    strip.append(el("img", {
                        class: "thumb",
                        src: thumbSrc,
                        alt: `${w.name} ì‚¬ì§„`,
                        loading: "lazy",
                        decoding: "async",
                        onClick: open
                    }))
                }
            })

            // ë³¸ë¬¸ ì¡°ë¦½ (authorAttrì€ ìˆì„ ë•Œë§Œ ì¶”ê°€)
            const body = el("div", { class: "body" },
                titleLine,
                stats1,
                stats2,
                capRow,
                hpRow,
                tagWrap,
                desc,
                strip
            )

            return el("article", { class: "card" }, hero, body)
        }

        function repeatString(s, n)
        {
            n = Math.floor(n)
            if (!(n >= 0 && Number.isFinite(n)))
            {
                throw new RangeError('nì€ 0 ì´ìƒì˜ ìœ í•œí•œ ì •ìˆ˜ì—¬ì•¼ í•´')
            }
            const str = String(s)
            if (typeof ''.repeat === 'function') return str.repeat(n) // ìµœì‹  ì—”ì§„

            // í´ë°±: ì§€ìˆ˜ì  ë³µì œ
            let out = ''
            let pat = str
            while (n > 0)
            {
                if (n & 1) out += pat
                n >>= 1
                if (n) pat += pat
            }
            return out
        }

        const _precache = new Set()
        function preload(src) { if (!src || _precache.has(src)) return; const img = new Image(); img.decoding = "async"; img.src = src; _precache.add(src) }
        function preloadNeighbors(list, i)
        {
            const L = list.length; if (!L) return
            const idxs = [i - 1, i + 1, i - 2, i + 2].map(x => (x % L + L) % L)

            for (const j of idxs)
            {
                const url = list[j]
                const cached = _imgCache.get(url)
                if (cached?.complete) continue

                const img = cached instanceof Image ? cached : new Image()
                img.decoding = "async"
                // ì´ë¯¸ ìš”ì²­ ì¤‘ì´ë©´ src ì¬ì„¤ì • ì•ˆ í•´ë„ ë¨(ë¸Œë¼ìš°ì €ê°€ ì¤‘ë³µ ë³‘í•©)
                if (!cached)
                {
                    img.src = url
                    _imgCache.set(url, img)
                }
            }
        }
        function preloadThumbNeighbors(thumbs, i)
        {
            const L = thumbs?.length || 0; if (!L) return
            const idxs = [i, i - 1, i + 1, i - 2, i + 2].map(x => (x % L + L) % L)
            for (const j of idxs)
            {
                const u = thumbs[j]
                if (!u || _thumbCache.get(u)?.complete) continue
                const img = new Image()
                img.decoding = "async"
                img.src = u
                _thumbCache.set(u, img)
            }
        }

        function _applyFitByAspect(imgEl, w, h)
        {
            imgEl.classList.remove('portrait', 'landscape')
            if (w > 0 && h > 0 && (w / h) < 1) imgEl.classList.add('portrait')
            else imgEl.classList.add('landscape') // ì •ì‚¬ê°í˜•ì€ ê°€ë¡œ ì·¨ê¸‰
        }

        // ìŠ¤í¬ë¡¤ ì ê¸ˆ: body ê³ ì • + ìŠ¤í¬ë¡¤ ì…ë ¥ ì°¨ë‹¨(íœ /í„°ì¹˜/í‚¤)
        // ìŠ¤í¬ë¡¤ ì ê¸ˆ: body ê³ ì • + ìŠ¤í¬ë¡¤ ì…ë ¥ ì°¨ë‹¨(íœ /í„°ì¹˜/í‚¤)
        const _scrollLock = { y: 0, wheel: null, touch: null, key: null }

        function lockScroll()
        {
            const doc = document
            const docEl = doc.documentElement

            // â˜… í˜„ì¬ ìŠ¤í¬ë¡¤ë°” í­(px) ì¸¡ì • â†’ CSS ë³€ìˆ˜ë¡œ ì €ì¥ (ë ˆì´ì•„ì›ƒ ë³´ì •ì— ì‚¬ìš©)
            //  ì´ ê³„ì‚°ì€ bodyë¥¼ ê³ ì •ì‹œí‚¤ê¸° "ì „ì—" í•´ì•¼ ì •í™•í•¨
            const sbw = Math.max(0, window.innerWidth - docEl.clientWidth)
            docEl.style.setProperty('--sbw', sbw + 'px')

            _scrollLock.y = window.scrollY || 0
            document.body.style.setProperty('--lock-top', `-${_scrollLock.y}px`)
            document.body.classList.add('body-lock') // â† ì—¬ê¸°ì„œ bodyì— ë³´ì • íŒ¨ë”©ì´ ì ìš©ë¨

            // ìŠ¤í¬ë¡¤ ì…ë ¥ ì°¨ë‹¨
            _scrollLock.wheel = (e) => { e.preventDefault() }
            _scrollLock.touch = (e) => { e.preventDefault() }
            _scrollLock.key = (e) =>
            {
                const k = e.key
                if (k === ' ' || k === 'PageUp' || k === 'PageDown' || k === 'Home' || k === 'End' ||
                    k === 'ArrowUp' || k === 'ArrowDown' || k === 'ArrowLeft' || k === 'ArrowRight')
                {
                    e.preventDefault()
                }
            }
            window.addEventListener('wheel', _scrollLock.wheel, { passive: false })
            window.addEventListener('touchmove', _scrollLock.touch, { passive: false })
            window.addEventListener('keydown', _scrollLock.key, { passive: false })
        }

        function unlockScroll()
        {
            // ì…ë ¥ ì´ë²¤íŠ¸ í•´ì œ
            if (_scrollLock.wheel) window.removeEventListener('wheel', _scrollLock.wheel)
            if (_scrollLock.touch) window.removeEventListener('touchmove', _scrollLock.touch)
            if (_scrollLock.key) window.removeEventListener('keydown', _scrollLock.key)

            document.body.classList.remove('body-lock')
            document.body.style.removeProperty('--lock-top')

            // â˜… ë³´ì •ì— ì¼ë˜ ë³€ìˆ˜ ì›ë³µ
            document.documentElement.style.removeProperty('--sbw')

            // ì›ë˜ ìœ„ì¹˜ ë³µê·€
            window.scrollTo(0, _scrollLock.y || 0)

            _scrollLock.wheel = _scrollLock.touch = _scrollLock.key = null
        }

        // ì¤„ë³„ë¡œ .title-line ë†’ì´ë¥¼ ë§ì¶° ì†ì„± ì‹œì‘ì„ ì„ ì •ë ¬
        function alignTitleHeights()
        {
            const cards = Array.from(grid.querySelectorAll('.card'))
            if (!cards.length) return

            // ê¸°ì¡´ minHeight ë¦¬ì…‹
            for (const c of cards)
            {
                const t = c.querySelector('.title-line')
                if (t) t.style.minHeight = ''
            }

            // ê°™ì€ ì¤„ ë¬¶ê¸°: offsetTopì´ ê°™ì€ ì¹´ë“œ = ê°™ì€ í–‰
            const rows = new Map()
            for (const c of cards)
            {
                const y = c.offsetTop                 // ì •ìˆ˜ë¼ ê·¸ë£¹í•‘ì— ì¶©ë¶„
                if (!rows.has(y)) rows.set(y, [])
                rows.get(y).push(c)
            }

            // ê° í–‰ì—ì„œ ì œëª© ë¸”ë¡ ìµœëŒ€ ë†’ì´ë¥¼ ì°¾ì•„ ì¼ê´„ ì ìš©
            for (const group of rows.values())
            {
                let maxH = 100
                for (const c of group)
                {
                    const t = c.querySelector('.title-line')
                    if (!t) continue
                    const h = t.getBoundingClientRect().height
                    if (h > maxH) maxH = h
                }
                if (maxH > 0)
                {
                    for (const c of group)
                    {
                        const t = c.querySelector('.title-line')
                        if (t) t.style.minHeight = Math.ceil(maxH) + 'px'
                    }
                }
            }
        }

        // ë¦¬ì‚¬ì´ì¦ˆ/í°íŠ¸ ë¡œë“œ í›„ë„ ë‹¤ì‹œ ë§ì¶¤
        const alignTitleHeightsDebounced = (() =>
        {
            let tid = null
            return () =>
            {
                clearTimeout(tid)
                tid = setTimeout(() =>
                {
                    requestAnimationFrame(alignTitleHeights)
                }, 80)
            }
        })()
        window.addEventListener('resize', alignTitleHeightsDebounced)
        document.fonts?.ready?.then(() => alignTitleHeights())


        /* ì •ë ¬ & ë Œë” */
        function render()
        {
            grid.innerHTML = ""
            const list = [...STATE.worlds]
            const key = STATE.sort
            const cmp = {
                added: (a, b) => (b.addedTs || 0) - (a.addedTs || 0),
                added_old: (a, b) => (a.addedTs || 0) - (b.addedTs || 0),
                visits: (a, b) => (b.visits || 0) - (a.visits || 0),
                favorites: (a, b) => (b.favorites || 0) - (a.favorites || 0),
                favratio: (a, b) => favRatioNum(b) - favRatioNum(a),
                updated: (a, b) => (b.updatedTs || toTs(b.updated_at)) - (a.updatedTs || toTs(a.updated_at)),
                heat: (a, b) => (b.heat || 0) - (a.heat || 0),
                popularity: (a, b) => (b.popularity || 0) - (a.popularity || 0),
            }[key] || ((a, b) => 0)

            list.sort(cmp)
            list.forEach(w => grid.append(card(w)))
            requestAnimationFrame(alignTitleHeights)
        }

        sortSel.value = STATE.sort
        sortSel.addEventListener("change", () =>
        {
            STATE.sort = sortSel.value
            localStorage.setItem("sort", STATE.sort)
            render()
        });

        /* ë°ì´í„° ë¡œë“œ */
        (async () =>
        {
            status.textContent = "ì›”ë“œ ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘â€¦"
            try
            {
                const r = await fetch("/api/worlds")
                if (!r.ok) throw new Error("HTTP " + r.status)
                const { worlds } = await r.json()
                STATE.worlds = worlds
                status.textContent = ""
                render()
            } catch (e)
            {
                status.textContent = "ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨: " + e.message
            }
        })()

        // ì „ì—­ ë‹¨ì¶•í‚¤: íŒì—…ì´ ì—´ë ¤ ìˆì„ ë•Œë§Œ ë™ì‘
        function onKeyGlobal(e)
        {
            if (!light.hasAttribute("open")) return
            if (e.key === "Escape")
            {
                e.preventDefault()
                closeLight()
            } else if (e.key === "ArrowLeft")
            {
                e.preventDefault()
                move(-1)
            } else if (e.key === "ArrowRight")
            {
                e.preventDefault()
                move(1)
            }
        }

        window.addEventListener("keydown", onKeyGlobal)

        let _lbRsvTid = null
        window.addEventListener('resize', () =>
        {
            if (!light.hasAttribute('open')) return
            clearTimeout(_lbRsvTid)
            _lbRsvTid = setTimeout(() => requestAnimationFrame(updateLbReserve), 80)
        });
    </script>
</body>

</html>